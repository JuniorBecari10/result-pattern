export type Result<V, E> = Ok<V, E> | Fail<V, E>;

interface IResult<V, E> {
	readonly isOk: boolean;
	readonly isFail: boolean;
	readonly value: V | E;

	map<NextV>(mapFn: (value: V) => NextV): Result<NextV, E>;
	flatMap<NextV>(mapFn: (value: V) => Result<NextV, E>): Result<NextV, E>;
	mapFails<NextE>(mapFn: (value: E) => NextE): Result<V, NextE>;
	flip(): Result<E, V>;

	unwrap(): V;
	unwrapOr(defaultValue: V): V;
	unwrapOrElse(fn: () => V): V;
	expect(message: string): V;

	and<NextV>(result: Result<NextV, E>): Result<NextV, E>;
	or(result: Result<V, E>): Result<V, E>;
}

export class Ok<V = never, E = never> implements IResult<V, E> {
	public readonly isOk = true as const;
	public readonly isFail = false as const;

	public constructor(public readonly value: V) {}

	// ✅ Transforms the value if it is Ok
	public map<NextV>(mapFn: (value: V) => NextV): Result<NextV, E> {
		return new Ok(mapFn(this.value));
	}

	// ✅ Chains computations if it is Ok
	public flatMap<NextV>(
		mapFn: (value: V) => Result<NextV, E>,
	): Result<NextV, E> {
		return mapFn(this.value);
	}

	// ✅ Doesn't modify the value since it's already Ok
	public mapFails<NextE>(_: (value: E) => NextE): Result<V, NextE> {
		return new Ok(this.value);
	}

	// ✅ Converts Ok to Fail
	public flip(): Result<E, V> {
		return new Fail(this.value);
	}

	// ✅ Returns the inner value or throws if Fail
	public unwrap(): V {
		return this.value;
	}

	// ✅ Returns the value or a default one
	public unwrapOr(defaultValue: V): V {
		return this.value;
	}

	// ✅ Returns the value or executes a function to generate one
	public unwrapOrElse(fn: () => V): V {
		return this.value;
	}

	// ✅ Returns the value or throws an error with a custom message
	public expect(_: string): V {
		return this.value;
	}

	// ✅ Returns another Result if Ok, otherwise keeps the Fail
	public and<NextV>(result: Result<NextV, E>): Result<NextV, E> {
		return result;
	}

	// ✅ Keeps the current Ok, or returns another Result if Fail
	public or(_: Result<V, E>): Result<V, E> {
		return this;
	}
}

export class Fail<V = never, E = never> implements IResult<V, E> {
	public readonly isOk = false as const;
	public readonly isFail = true as const;

	public constructor(public readonly value: E) {}

	// ✅ Doesn't modify the value since it's a Fail
	public map<NextV>(_: (value: V) => NextV): Result<NextV, E> {
		return new Fail(this.value);
	}

	// ✅ Doesn't modify the value since it's a Fail
	public flatMap<NextV>(_: (value: V) => Result<NextV, E>): Result<NextV, E> {
		return new Fail(this.value);
	}

	// ✅ Transforms the error if it is a Fail
	public mapFails<NextE>(mapFn: (value: E) => NextE): Result<V, NextE> {
		return new Fail(mapFn(this.value));
	}

	// ✅ Converts Fail to Ok
	public flip(): Result<E, V> {
		return new Ok(this.value);
	}

	// ❌ Throws an error because Fail has no valid value
	public unwrap(): V {
		throw new Error("Tried to unwrap a Fail result");
	}

	// ✅ Returns a default value instead of throwing
	public unwrapOr(defaultValue: V): V {
		return defaultValue;
	}

	// ✅ Returns a value generated by a function
	public unwrapOrElse(fn: () => V): V {
		return fn();
	}

	// ❌ Throws an error with a custom message
	public expect(message: string): V {
		throw new Error(message);
	}

	// ✅ Always returns Fail
	public and<NextV>(_: Result<NextV, E>): Result<NextV, E> {
		return new Fail(this.value);
	}

	// ✅ Returns another Result if this is a Fail
	public or(result: Result<V, E>): Result<V, E> {
		return result;
	}
}

export namespace ResultUtils {
	type OkValues<T extends readonly Result<unknown, unknown>[]> = {
		[K in keyof T]: T[K] extends Result<infer V, unknown> ? V : never;
	};
	type FailValues<T extends readonly Result<unknown, unknown>[]> =
		T extends readonly Result<unknown, infer E>[] ? E[] : never;

	// ✅ Combines multiple Results into one
	export function combine<T extends readonly Result<unknown, unknown>[]>(
		...results: T
	): Result<OkValues<T>, FailValues<T>> {
		const fails = results.filter((r): r is Fail<unknown, unknown> => r.isFail);

		if (fails.length > 0) {
			const failValues = fails.map((f) => f.value) as FailValues<T>;
			return new Fail(failValues);
		}

		const okValues = results.map((r) => r.value) as OkValues<T>;
		return new Ok(okValues);
	}
}
